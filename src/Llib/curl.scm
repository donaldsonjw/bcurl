(module bcurl/curl
   (extern
      (include "curl/curl.h")
      (type int* (pointer int) "int*")
      (type string* (pointer string) "char**")
      (type curl-slist (struct
                          (data::string "data")
                          (next::curl-slist* "next"))
         "struct curl_slist")
      (type curl (struct) "CURL")
      (type curl-multi (struct) "CURLM")
      (type curl-mime (struct) "curl_mime")
      (type curl-mimepart (struct) "curl_mimepart")
      (type curl-msg-type
         (enum
            (curlmsg-done "CURLMSG_DONE"))
         "CURLMSG")
      (type curl-msg (struct
                        (type::curl-msg-type "msg")
                        (handle::curl* "easy_handle")
                        (result::curl-code "data.result")
                        ) "CURLMsg")
      (type curl-opt (enum) "CURLoption")
      (type curl-info (enum) "CURLINFO")
      (type curl-socktype (enum (ipx "CURLSOCKTYPE_IPCXN")
                             (accept "CURLSOCKTYPE_ACCEPT"))
         "curlsocktype")
      (type curl-sockaddr (struct
                             (family::int "family")
                             (socktype::int "socktype")
                             (protocol::int "protocol"))
         "struct curl_sockaddr")
      (type curl-write-callback (function long (string long long void*)) "curl_write_callback")
      (type curl-read-callback (function ulong (string ulong ulong void*)) "curl_read_callback")
      (type curl-seek-callback (function int (void* long int)) "curl_seek_callback")
      (type curl-progress-callback (function int (void* int64 int64 int64 int64)) "curl_xferinfo_callback")
      (type curl-malloc-callback (function void* (long)) "curl_malloc_callback")
      (type curl-free-callback (function void (void*)) "curl_free_callback")
      (type curl-realloc-callback (function void* (void* long)) "curl_realloc_callback")
      (type curl-strdup-callback (function string (string)) "curl_strdup_callback")
      (type curl-calloc_callback (function void (long long)) "curl_calloc_callback")
      (type curl-opensocket-callback (function int (void* curl-socktype curl-sockaddr*))
         "curl_opensocket_callback")
      (type curl-sockopt-callback (function int (void* int curl-socktype))
         "curl_sockopt_callback")
      (type curl-closesocket-callback (function int (void* int))
         "curl_closesocket_callback")
      (type curl-code
         (enum
            (curle-ok "CURLE_OK")
            (curle-unsupported-protocol "CURLE_UNSUPPORTED_PROTOCOL")
            (curle-failed-init "CURLE_FAILED_INIT")
            (curle-url-malformat "CURLE_URL_MALFORMAT")
            (curle-not-built-in "CURLE_NOT_BUILT_IN")
            (curle-couldnt-resolve-proxy "CURLE_COULDNT_RESOLVE_PROXY")
            (curle-couldnt-resolve-host "CURLE_COULDNT_RESOLVE_HOST")
            (curle-couldnt-connect "CURLE_COULDNT_CONNECT")
            (curle-weird-server-reply "CURLE_WEIRD_SERVER_REPLY")
            (curle-remote-access-denied "CURLE_REMOTE_ACCESS_DENIED")
            (curle-ftp-accept-failed "CURLE_FTP_ACCEPT_FAILED")
            (curle-ftp-weird-pass-reply "CURLE_FTP_WEIRD_PASS_REPLY")
            (curle-ftp-accept-timeout "CURLE_FTP_ACCEPT_TIMEOUT")
            (curle-ftp-weird-pasv-reply "CURLE_FTP_WEIRD_PASV_REPLY")
            (curle-ftp-weird-227-format "CURLE_FTP_WEIRD_227_FORMAT")
            (curle-ftp-cant-get-host "CURLE_FTP_CANT_GET_HOST")
            ;(curle-http "CURLE_HTTP")
            (curle-ftp-couldnt-set-type "CURLE_FTP_COULDNT_SET_TYPE")
            (curle-partial-file "CURLE_PARTIAL_FILE")
            (curle-ftp-couldnt-retr-file "CURLE_FTP_COULDNT_RETR_FILE")
            (curle-obsolete20 "CURLE_OBSOLETE20")
            (curle-quote-error "CURLE_QUOTE_ERROR")
            (curle-http-returned-error "CURLE_HTTP_RETURNED_ERROR")
            (curle-write-error "CURLE_WRITE_ERROR")
            (curle-obsolete24 "CURLE_OBSOLETE24")
            (curle-upload-failed "CURLE_UPLOAD_FAILED")
            (curle-read-error "CURLE_READ_ERROR")
            (curle-out-of-memory "CURLE_OUT_OF_MEMORY")
            (curle-operation-timedout "CURLE_OPERATION_TIMEDOUT")
            (curle-obsolete29 "CURLE_OBSOLETE29")
            (curle-ftp-port-failed "CURLE_FTP_PORT_FAILED")
            (curle-ftp-couldnt-use-rest "CURLE_FTP_COULDNT_USE_REST")
            (curle-obsolete32 "CURLE_OBSOLETE32")
            (curle-range-error "CURLE_RANGE_ERROR")
            (curle-http-post-error "CURLE_HTTP_POST_ERROR")
            (curle-ssl-connect-error "CURLE_SSL_CONNECT_ERROR")
            (curle-bad-download-resume "CURLE_BAD_DOWNLOAD_RESUME")
            (curle-file-couldnt-read-file "CURLE_FILE_COULDNT_READ_FILE")
            (curle-ldap-cannot-bind "CURLE_LDAP_CANNOT_BIND")
            (curle-ldap-search-failed "CURLE_LDAP_SEARCH_FAILED")
            (curle-obsolete40 "CURLE_OBSOLETE40")
            (curle-function-not-found "CURLE_FUNCTION_NOT_FOUND")
            (curle-aborted-by-callback "CURLE_ABORTED_BY_CALLBACK")
            (curle-bad-function-argument "CURLE_BAD_FUNCTION_ARGUMENT")
            (curle-obsolete44 "CURLE_OBSOLETE44")
            (curle-interface-failed "CURLE_INTERFACE_FAILED")
            (curle-obsolete46 "CURLE_OBSOLETE46")
            (curle-too-many-redirects "CURLE_TOO_MANY_REDIRECTS")
            (curle-unknown-option "CURLE_UNKNOWN_OPTION")
            (curle-telnet-option-syntax "CURLE_TELNET_OPTION_SYNTAX")
            (curle-obsolete50 "CURLE_OBSOLETE50")
            (curle-obsolete51 "CURLE_OBSOLETE51")
            (curle-got-nothing "CURLE_GOT_NOTHING")
            (curle-ssl-engine-notfound "CURLE_SSL_ENGINE_NOTFOUND")
            (curle-ssl-engine-setfailed "CURLE_SSL_ENGINE_SETFAILED")
            (curle-send-error "CURLE_SEND_ERROR")
            (curle-recv-error "CURLE_RECV_ERROR")
            (curle-obsolete57 "CURLE_OBSOLETE57")
            (curle-ssl-certproblem "CURLE_SSL_CERTPROBLEM")
            (curle-ssl-cipher "CURLE_SSL_CIPHER")
            (curle-peer-failed-verification "CURLE_PEER_FAILED_VERIFICATION")
            (curle-bad-content-encoding "CURLE_BAD_CONTENT_ENCODING")
            (curle-ldap-invalid-url "CURLE_LDAP_INVALID_URL")
            (curle-filesize-exceeded "CURLE_FILESIZE_EXCEEDED")
            (curle-use-ssl-failed "CURLE_USE_SSL_FAILED")
            (curle-send-fail-rewind "CURLE_SEND_FAIL_REWIND")
            (curle-ssl-engine-initfailed "CURLE_SSL_ENGINE_INITFAILED")
            (curle-login-denied "CURLE_LOGIN_DENIED")
            (curle-tftp-notfound "CURLE_TFTP_NOTFOUND")
            (curle-tftp-perm "CURLE_TFTP_PERM")
            (curle-remote-disk-full "CURLE_REMOTE_DISK_FULL")
            (curle-tftp-illegal "CURLE_TFTP_ILLEGAL")
            (curle-tftp-unknownid "CURLE_TFTP_UNKNOWNID")
            (curle-remote-file-exists "CURLE_REMOTE_FILE_EXISTS")
            (curle-tftp-nosuchuser "CURLE_TFTP_NOSUCHUSER")
            (curle-conv-failed "CURLE_CONV_FAILED")
            (curle-conv-reqd "CURLE_CONV_REQD")
            (curle-ssl-cacert-badfile "CURLE_SSL_CACERT_BADFILE")
            (curle-remote-file-not-found "CURLE_REMOTE_FILE_NOT_FOUND")
            (curle-ssh "CURLE_SSH")
            (curle-ssl-shutdown-failed "CURLE_SSL_SHUTDOWN_FAILED")
            (curle-again "CURLE_AGAIN")
            (curle-ssl-crl-badfile "CURLE_SSL_CRL_BADFILE")
            (curle-ssl-issuer-error "CURLE_SSL_ISSUER_ERROR")
            (curle-ftp-pret-failed "CURLE_FTP_PRET_FAILED")
            (curle-rtsp-cseq-error "CURLE_RTSP_CSEQ_ERROR")
            (curle-rtsp-session-error "CURLE_RTSP_SESSION_ERROR")
            (curle-ftp-bad-file-list "CURLE_FTP_BAD_FILE_LIST")
            (curle-chunk-failed "CURLE_CHUNK_FAILED")
            (curle-no-connection-available "CURLE_NO_CONNECTION_AVAILABLE")
            (curle-ssl-pinnedpubkeynotmatch "CURLE_SSL_PINNEDPUBKEYNOTMATCH")
            (curle-ssl-invalidcertstatus "CURLE_SSL_INVALIDCERTSTATUS")
            (curle-http2-stream "CURLE_HTTP2_STREAM")
            (curle-recursive-api-call "CURLE_RECURSIVE_API_CALL"))
         "CURLcode")
      (type curl-multi-code
         (enum
            (curlm-call-multi-perform "CURLM_CALL_MULTI_PERFORM")
            (curlm-ok "CURLM_OK")
            (curlm-bad-handle "CURLM_BAD_HANDLE")
            (curlm-bad-easy-handle "CURLM_BAD_EASY_HANDLE")
            (curlm-out-of-memory "CURLM_OUT_OF_MEMORY")
            (curlm-internal-error "CURLM_INTERNAL_ERROR")
            (curlm-bad-socket "CURLM_BAD_SOCKET")
            (curlm-unknown-option "CURLM_UNKNOWN_OPTION")
            (curlm-added-already "CURLM_ADDED_ALREADY")
            (curlm-recursive-api-call "CURLM_RECURSIVE_API_CALL")
            (curlm-wakeup-failure "CURLM_WAKEUP_FAILURE")
            (curlm-bad-function-argument "CURLM_BAD_FUNCTION_ARGUMENT"))
         "CURLMcode")
      (macro addr-of-int::int* (val::int) "&")
      (macro curl-slist-append::curl-slist* (lst::curl-slist* str::string)
         "curl_slist_append")
      (curl-slist-free-all::void (slist::curl-slist*) "curl_slist_free_all")
      (macro curl-global-all::long "CURL_GLOBAL_ALL")
      (macro gc-malloc::curl-malloc-callback "GC_malloc")
      (gc-strdup::curl-strdup-callback "GC_strdup")
      (macro gc-free::curl-free-callback "GC_free")
      (macro gc-realloc::curl-realloc-callback "GC_realloc")
      (macro gc-calloc::curl-calloc_callback "GC_malloc")
      (macro curl-global-init::curl-code (flags::long) "curl_global_init")
      (macro curl-global-init-mem::curl-code (flags::long malloc::curl-malloc-callback
                                      free::curl-free-callback
                                      realloc::curl-realloc-callback
                                      strdup::curl-strdup-callback
                                      calloc::curl-calloc_callback) "curl_global_init_mem")
      (curl-global-cleanup::void () "curl_global_cleanup")
      (curl-easy-init::curl* () "curl_easy_init")
      (curl-multi-init::curl* () "curl_multi_init")
      (curl-mime-init::curl-mime* (handle::curl*) "curl_mime_init")
      (curl-mime-free::void (handle::curl-mime*) "curl_mime_free")
      (curl-mime-addpart::curl-mimepart* (mime::curl-mime*) "curl_mime_addpart")
      (macro curl-mime-name::curl-code (part::curl-mimepart* name::string)
         "curl_mime_name")
      (macro curl-mime-data::curl-code (part::curl-mimepart* data::string size::uint64)
             "curl_mime_data")
      (macro curl-mime-type::curl-code (part::curl-mimepart* type::string)
             "curl_mime_type")
      (macro curl-mime-filename::curl-code (part::curl-mimepart* file-name::string)
             "curl_mime_filename")
      (macro curl-mime-filedata::curl-code (part::curl-mimepart* file-name::string)
             "curl_mime_filename")
      (macro curl-mime-data-cb::curl-code (part::curl-mimepart* data-size::long read::curl-read-callback
                                       seek::curl-seek-callback curl-free-callback arg::void*)
             "curl_mime_data_cb")
      (curl-mime-subparts::curl-code (part::curl-mimepart* subparts::curl-mime*)
         "curl_mime_subparts")
      (curl-mime-headers::curl-code (part::curl-mimepart* headers::curl-slist* take-ownership::int)
         "curl_mime_headers")
      (curl-easy-cleanup::void (handle::curl*) "curl_easy_cleanup")
      (curl-multi-cleanup::curl-multi-code (handle::curl-multi*) "curl_multi_cleanup")
      (curl-multi-add-handle::curl-multi-code (multi::curl-multi* handle::curl*) "curl_multi_add_handle")
      (curl-multi-remove-handle::curl-multi-code (multi::curl-multi* handle::curl*) "curl_multi_remove_handle")
      (curl-multi-perform::curl-multi-code (multi::curl-multi* running::int*) "curl_multi_perform")
      (curl-multi-info-read::curl-msg* (multi::curl-multi* remaining_msgs::int*) "curl_multi_info_read")
      (curl-multi-wakeup::curl-multi-code (multi::curl-multi*) "curl_multi_wakeup")
      (macro curl-easy-setopt::curl-code
         (handle::curl* option::curl-opt parameter::void*)
         "curl_easy_setopt")
      (macro curl-easy-getinfo::curl-code
         (handle::curl* info::curl-info data::void*)
         "curl_easy_getinfo")
      (curl-easy-perform::curl-code (handle::curl*) "curl_easy_perform")
      (export bigloo-write-callback "bigloo_write_callback")
      (export bigloo-read-callback "bigloo_read_callback")
      (export bigloo-progress-callback "bigloo_progress_callback")
      (export bigloo-header-callback "bigloo_header_callback")
      (export bigloo-opensocket-callback "bigloo_opensocket_callback")
      (export bigloo-sockopt-callback "bigloo_sockopt_callback")
      (export bigloo-closesocket-callback "bigloo_closesocket_callback")
      (export bigloo-seek-callback "bigloo_seek_callback")
      (macro $bigloo-write-callback::curl-write-callback "bigloo_write_callback")
      (macro $bigloo-read-callback::curl-read-callback "bigloo_read_callback")
      (macro $bigloo-progress-callback::curl-progress-callback
         "bigloo_progress_callback")
      (macro $bigloo-seek-callback::curl-seek-callback "bigloo_seek_callback")
      (macro $bigloo-header-callback::curl-write-callback "bigloo_header_callback")
      (macro $bigloo-opensocket-callback::curl-opensocket-callback "bigloo_opensocket_callback")
      (macro $bigloo-sockopt-callback::curl-sockopt-callback "bigloo_sockopt_callback")
      (macro $bigloo-closesocket-callback::curl-closesocket-callback "bigloo_closesocket_callback")
      (macro $curl-socket-bad::int "CURL_SOCKET_BAD")
      (macro $curl-sockopt-ok::int "CURL_SOCKOPT_OK")
      (macro $curl-sockopt-error::int "CURL_SOCKOPT_ERROR")
      (macro $curl-sockopt-already-connected::int "CURL_SOCKOPT_ALREADY_CONNECTED")
      (macro $curl-seekfunc-ok::int "CURL_SEEKFUNC_OK")
      (macro $curl-seekfunc-fail::int "CURL_SEEKFUNC_FAIL")
      (macro $curl-seekfunc-cantseek::int "CURL_SEEKFUNC_CANTSEEK")
      (macro $seek-set::int "SEEK_SET")
      (macro $seek-cur::int "SEEK_CUR")
      (macro $seek-end::int "SEEK_END")
      (macro $EINVAL::int "EINVAL")
      (macro $ESPIPE::int "ESPIPE"))   
   (export
      (class &curl-initialization-exception::&error)
      (class &curl-cleanup-exception::&error)
      (curl-init)
      (curl-option-set! handle::obj option-name::symbol val::obj)
      (make-curl)
      (curl-cleanup! handle::obj)
      (curl-perform! handle)
      (bigloo-write-callback::long data::string
         size::long num-members::long user-data::void*)
      (bigloo-read-callback::ulong buffer::string size::ulong num-items::ulong
         user-data::void*)
      (bigloo-progress-callback::int user-data::void*
         download-total::int64 download-now::int64 upload-total::int64
         upload-now::int64)
      (bigloo-header-callback::long data::string
         size::long num-members::long user-data::void*)
      (bigloo-opensocket-callback::int clientp::void* purpose::curl-socktype
         addr::curl-sockaddr*)
      (bigloo-closesocket-callback::int clientp::void* item::int)
      (bigloo-sockopt-callback::int clientp::void* fd::int purpose::curl-socktype)
      (header-list->curl-slist headers::pair-nil)
      (curl-slist-free lst::curl-slist*)
      (curl-get-info handle::curl* info::symbol)
      
      (make-curl-multi)
      (curl-multi-cleanup! handle)
      (curl-multi-add-handle! multi handle)
      (curl-multi-perform! multi)
      (curl-multi-info-read! multi)
      (make-curl-mime handle)
      (curl-mime-addpart! mime)
      (curl-mime-data! part data::bstring)
      (curl-mime-type! part type::bstring)
      (curl-mime-free! mime)
      (curl-mime-filename! part filename::bstring)
      (curl-mime-data-port! part port)
      (bigloo-seek-callback::int instream::void* offset::long origin::int)
      (curl-cleanup-handler-add! handle handler::procedure)
      (curl-mime-name! part name::bstring)
      (curl-mime-subparts! part subparts)
      (curl-mime-headers! part headers::pair-nil)
      (curl-mime-filedata! part filename::bstring)
      (curl-multi-remove-handle! multi handle)))


(define (curl-socktype->symbol socktype::curl-socktype)
   (cond ((=curl-socktype? socktype (curl-socktype-ipx))
          'ipx)
         ((=curl-socktype? socktype (curl-socktype-accept))
          'accept)
         (else
          (error "curl-socktype->symbol" "unknown socktype" socktype))))

(define (bsocket->fd::int s::socket)
   (pragma::int "((obj_t)$1)->socket.fd" s))

(define-syntax bcurl-void*->obj
   (syntax-rules ()
      ((_ v)
       (pragma::obj "((obj_t)$1)" v))))

(define-syntax bcurl->void*
   (syntax-rules ()
      ((_ v)
       (pragma::void* "((void*) $1)" v))))

;;; table mapping option symbol to enum value, validator, and converter
(define *curl-options* (create-hashtable :size 300))

(define (curl-option? sym::symbol)
   (hashtable-contains? *curl-options* sym))

(define +curl-type-long+ 0)
(define +curl-type-object+ 10000)
(define +curl-type-string+ 10000)
(define +curl-type-function+ 20000)
(define +curl-type-off-t+ 30000)

(define (get-type-base-val::long type::symbol)
   (case type
      ((LONG) +curl-type-long+)
      ((OBJECTPOINT) +curl-type-object+)
      ((STRINGPOINT) +curl-type-string+)
      ((FUNCTIONPOINT) +curl-type-function+)
      ((OFF_T) +curl-type-off-t+)
      (else
       (error "get-type-base-val" "unknown type" type))))

(define (snake-case->lisp-case sym::symbol)
   (string->symbol
      (string-downcase!
         (string-replace (symbol->string sym) #\_ #\-))))


(define-struct option-data
   value
   validate
   convert)

(define (get-type-validator name type)
   (case type
      ((LONG OFF_T)
       (lambda (h v) (or (boolean? v)
                  (integer? v))))
      ((STRINGPOINT)
       (lambda (h v) (string? v)))
      ((FUNCTIONPOINT)
       (case name
          ((writefunction headerfunction)
           (lambda (h v) (curl-write-callback? v)))
          ((readfunction)
           (lambda (h v) (curl-read-callback? v)))
          ((seekfunction)
           (lambda (h v) (curl-seek-callback? v)))
          ((xferinfofunction)
           (lambda (h v) (curl-progress-callback? v)))
          ((opensocketfunction)
           (lambda (h v) (curl-opensocket-callback? v)))
          (else
           (lambda (h v)
              (error "validate" "unsupported function" name)))))
      ((OBJECTPOINT)
       (case name
          ((writedata headerdata)
           (lambda (h v) (or (not v) (output-port? v))))
          ((readdata)
           (lambda (h v) (or (not v) (input-port? v))))
          ((xferinfodata)
           (lambda (h v) (or (not v) (procedure? v))))
          ((opensocketdata)
           (lambda (h v) (socket? v)))
          ((sockoptdata)
           (lambda (h v) (procedure? v)))
          ((httpheader)
           (lambda (h v) (curl-slist*? v)))
          ((copypostfields)
           (lambda (h v) (string? v)))
          (else
           (lambda (h v)
              (error "validate" "unsupported object" name)))))
      (else
       (lambda (h v)
          (error "validate" "unsupported option" name)))))

(define (get-type-converter name type)
   (case type
      ((LONG OFF_T)
       (case name
          ((httpauth)
           (lambda::void* (h v)
              (let loop ((lst v)
                         (res::long 0))
                 (if (pair? lst)
                     (loop (cdr lst)
                        (bit-or res (auth-type->long (car lst))))
                     res))))
          (else
           (lambda::void* (h v)
              (let ((val::long
                       (cond ((fixnum? v)
                              (fixnum->elong v))
                             ((llong? v)
                              (llong->elong v))
                             ((bignum? v)
                              (bignum->elong v))
                             ((boolean? v)
                              (if v 1 0))
                             (else
                              (error "convert" "unsupported type" (typeof v))))))
                 (bcurl->void* val))))))
      ((STRINGPOINT)
       (lambda::void* (h v::string)
          (bcurl->void* v)))

      ((FUNCTIONPOINT)
       (case name
          ((writefunction headerfunction)
           (lambda::curl-write-callback (h wf::curl-write-callback)
              wf))
          ((readfunction)
           (lambda::curl-read-callback (h rf::curl-read-callback)
              rf))
          ((seekfunction)
           (lambda::curl-seek-callback (h sf::curl-seek-callback)
              sf))
          ((xferinfofunction)
           (lambda::curl-progress-callback (h xf::curl-progress-callback)
              xf))
          ((opensocketfunction)
           (lambda::curl-opensocket-callback (h of::curl-opensocket-callback)
              of))
          ((sockoptfunction)
           (lambda::curl-sockopt-callback (h sof::curl-sockopt-callback)
           sof))
          (else
           (lambda (h f)
              (error "convert" "unsupported funtion" name)))))
      ((OBJECTPOINT)
       (case name
          ((writedata readdata headerdata xferinfodata opensocketdata sockoptdata)
           (lambda::void* (h v)
              (bcurl->void* v)))
          ((httpheader)
           (lambda::curl-slist* (h v::curl-slist*)
              v))
          ((copypostfields)
           (lambda::void* (h v::string)
              (bcurl->void* v)))
          (else
           (lambda (h v)
              (error "convert" "unsupported object" name)))))
      (else
       (lambda (h v)
          (error "convert" "unsupported type conversion" type)))))

(define-syntax define-curl-option
   (syntax-rules ()
      ((_ name type val)
       (let ((option-name (snake-case->lisp-case (quote name))))
          (hashtable-put! *curl-options* option-name
             (option-data (+fx (get-type-base-val (quote type)) val)
                (get-type-validator option-name (quote type))
                (get-type-converter option-name (quote type))))))))


(define-curl-option WRITEDATA OBJECTPOINT 1)
(define-curl-option URL STRINGPOINT 2)
(define-curl-option PORT LONG 3)
(define-curl-option PROXY STRINGPOINT 4)
(define-curl-option USERPWD STRINGPOINT 5)
(define-curl-option PROXYUSERPWD STRINGPOINT 6)
(define-curl-option RANGE STRINGPOINT 7)
(define-curl-option READDATA OBJECTPOINT 9)
(define-curl-option ERRORBUFFER OBJECTPOINT 10)
(define-curl-option WRITEFUNCTION FUNCTIONPOINT 11)
(define-curl-option READFUNCTION FUNCTIONPOINT 12)
(define-curl-option TIMEOUT LONG 13)
(define-curl-option INFILESIZE LONG 14)
(define-curl-option REFERER STRINGPOINT 16)
(define-curl-option FTPPORT STRINGPOINT 17)
(define-curl-option USERAGENT STRINGPOINT 18)
(define-curl-option LOW_SPEED_LIMIT LONG 19)
(define-curl-option LOW_SPEED_TIME LONG 20)
(define-curl-option RESUME_FROM LONG 21)
(define-curl-option COOKIE STRINGPOINT 22)
(define-curl-option HTTPHEADER OBJECTPOINT 23)
(define-curl-option HTTPPOST OBJECTPOINT 24)
(define-curl-option SSLCERT STRINGPOINT 25)
(define-curl-option KEYPASSWD STRINGPOINT 26)
(define-curl-option CRLF LONG 27)
(define-curl-option QUOTE OBJECTPOINT 28)
(define-curl-option HEADERDATA OBJECTPOINT 29)
(define-curl-option COOKIEFILE STRINGPOINT 31)
(define-curl-option SSLVERSION LONG 32)
(define-curl-option TIMECONDITION LONG 33)
(define-curl-option TIMEVALUE LONG 34)
(define-curl-option CUSTOMREQUEST STRINGPOINT 36)
(define-curl-option STDERR OBJECTPOINT 37)
(define-curl-option POSTQUOTE OBJECTPOINT 39)
(define-curl-option VERBOSE LONG 41)
(define-curl-option HEADER LONG 42)
(define-curl-option NOPROGRESS LONG 43)
(define-curl-option NOBODY LONG 44)
(define-curl-option FAILONERROR LONG 45)
(define-curl-option UPLOAD LONG 46)
(define-curl-option POST LONG 47)
(define-curl-option DIRLISTONLY LONG 48)
(define-curl-option APPEND LONG 50)
(define-curl-option NETRC LONG 51)
(define-curl-option FOLLOWLOCATION LONG 52)
(define-curl-option TRANSFERTEXT LONG 53)
(define-curl-option PUT LONG 54)
(define-curl-option PROGRESSFUNCTION FUNCTIONPOINT 56)
(define-curl-option PROGRESSDATA OBJECTPOINT 57)
(define-curl-option XFERINFODATA OBJECTPOINT 57)
(define-curl-option AUTOREFERER LONG 58)
(define-curl-option PROXYPORT LONG 59)
(define-curl-option POSTFIELDSIZE LONG 60)
(define-curl-option HTTPPROXYTUNNEL LONG 61)
(define-curl-option INTERFACE STRINGPOINT 62)
(define-curl-option KRBLEVEL STRINGPOINT 63)
(define-curl-option SSL_VERIFYPEER LONG 64)
(define-curl-option CAINFO STRINGPOINT 65)
(define-curl-option MAXREDIRS LONG 68)
(define-curl-option FILETIME LONG 69)
(define-curl-option TELNETOPTIONS OBJECTPOINT 70)
(define-curl-option MAXCONNECTS LONG 71)
(define-curl-option FRESH_CONNECT LONG 74)
(define-curl-option FORBID_REUSE LONG 75)
(define-curl-option RANDOM_FILE STRINGPOINT 76)
(define-curl-option EGDSOCKET STRINGPOINT 77)
(define-curl-option CONNECTTIMEOUT LONG 78)
(define-curl-option HEADERFUNCTION FUNCTIONPOINT 79)
(define-curl-option HTTPGET LONG 80)
(define-curl-option SSL_VERIFYHOST LONG 81)
(define-curl-option COOKIEJAR STRINGPOINT 82)
(define-curl-option SSL_CIPHER_LIST STRINGPOINT 83)
(define-curl-option HTTP_VERSION LONG 84)
(define-curl-option FTP_USE_EPSV LONG 85)
(define-curl-option SSLCERTTYPE STRINGPOINT 86)
(define-curl-option SSLKEY STRINGPOINT 87)
(define-curl-option SSLKEYTYPE STRINGPOINT 88)
(define-curl-option SSLENGINE STRINGPOINT 89)
(define-curl-option SSLENGINE_DEFAULT LONG 90)
(define-curl-option DNS_CACHE_TIMEOUT LONG 92)
(define-curl-option PREQUOTE OBJECTPOINT 93)
(define-curl-option DEBUGFUNCTION FUNCTIONPOINT 94)
(define-curl-option DEBUGDATA OBJECTPOINT 95)
(define-curl-option COOKIESESSION LONG 96)
(define-curl-option CAPATH STRINGPOINT 97)
(define-curl-option BUFFERSIZE LONG 98)
(define-curl-option NOSIGNAL LONG 99)
(define-curl-option SHARE OBJECTPOINT 100)
(define-curl-option PROXYTYPE LONG 101)
(define-curl-option ACCEPT_ENCODING STRINGPOINT 102)
(define-curl-option PRIVATE OBJECTPOINT 103)
(define-curl-option HTTP200ALIASES OBJECTPOINT 104)
(define-curl-option UNRESTRICTED_AUTH LONG 105)
(define-curl-option FTP_USE_EPRT LONG 106)
(define-curl-option HTTPAUTH LONG 107)
(define-curl-option SSL_CTX_FUNCTION FUNCTIONPOINT 108)
(define-curl-option SSL_CTX_DATA OBJECTPOINT 109)
(define-curl-option FTP_CREATE_MISSING_DIRS LONG 110)
(define-curl-option PROXYAUTH LONG 111)
(define-curl-option FTP_RESPONSE_TIMEOUT LONG 112)
(define-curl-option IPRESOLVE LONG 113)
(define-curl-option MAXFILESIZE LONG 114)
(define-curl-option INFILESIZE_LARGE OFF_T 115)
(define-curl-option RESUME_FROM_LARGE OFF_T 116)
(define-curl-option MAXFILESIZE_LARGE OFF_T 117)
(define-curl-option NETRC_FILE STRINGPOINT 118)
(define-curl-option USE_SSL LONG 119)
(define-curl-option POSTFIELDSIZE_LARGE OFF_T 120)
(define-curl-option TCP_NODELAY LONG 121)
(define-curl-option FTPSSLAUTH LONG 129)
(define-curl-option IOCTLFUNCTION FUNCTIONPOINT 130)
(define-curl-option IOCTLDATA OBJECTPOINT 131)
(define-curl-option FTP_ACCOUNT STRINGPOINT 134)
(define-curl-option COOKIELIST STRINGPOINT 135)
(define-curl-option IGNORE_CONTENT_LENGTH LONG 136)
(define-curl-option FTP_SKIP_PASV_IP LONG 137)
(define-curl-option FTP_FILEMETHOD LONG 138)
(define-curl-option LOCALPORT LONG 139)
(define-curl-option LOCALPORTRANGE LONG 140)
(define-curl-option CONNECT_ONLY LONG 141)
(define-curl-option CONV_FROM_NETWORK_FUNCTION FUNCTIONPOINT 142)
(define-curl-option CONV_TO_NETWORK_FUNCTION FUNCTIONPOINT 143)
(define-curl-option CONV_FROM_UTF8_FUNCTION FUNCTIONPOINT 144)
(define-curl-option MAX_SEND_SPEED_LARGE OFF_T 145)
(define-curl-option MAX_RECV_SPEED_LARGE OFF_T 146)
(define-curl-option FTP_ALTERNATIVE_TO_USER STRINGPOINT 147)
(define-curl-option SOCKOPTFUNCTION FUNCTIONPOINT 148)
(define-curl-option SOCKOPTDATA OBJECTPOINT 149)
(define-curl-option SSL_SESSIONID_CACHE LONG 150)
(define-curl-option SSH_AUTH_TYPES LONG 151)
(define-curl-option SSH_PUBLIC_KEYFILE STRINGPOINT 152)
(define-curl-option SSH_PRIVATE_KEYFILE STRINGPOINT 153)
(define-curl-option FTP_SSL_CCC LONG 154)
(define-curl-option TIMEOUT_MS LONG 155)
(define-curl-option CONNECTTIMEOUT_MS LONG 156)
(define-curl-option HTTP_TRANSFER_DECODING LONG 157)
(define-curl-option HTTP_CONTENT_DECODING LONG 158)
(define-curl-option NEW_FILE_PERMS LONG 159)
(define-curl-option NEW_DIRECTORY_PERMS LONG 160)
(define-curl-option POSTREDIR LONG 161)
(define-curl-option SSH_HOST_PUBLIC_KEY_MD5 STRINGPOINT 162)
(define-curl-option OPENSOCKETFUNCTION FUNCTIONPOINT 163)
(define-curl-option OPENSOCKETDATA OBJECTPOINT 164)
(define-curl-option COPYPOSTFIELDS OBJECTPOINT 165)
(define-curl-option PROXY_TRANSFER_MODE LONG 166)
(define-curl-option SEEKFUNCTION FUNCTIONPOINT 167)
(define-curl-option SEEKDATA OBJECTPOINT 168)
(define-curl-option CRLFILE STRINGPOINT 169)
(define-curl-option ISSUERCERT STRINGPOINT 170)
(define-curl-option ADDRESS_SCOPE LONG 171)
(define-curl-option CERTINFO LONG 172)
(define-curl-option USERNAME STRINGPOINT 173)
(define-curl-option PASSWORD STRINGPOINT 174)
(define-curl-option PROXYUSERNAME STRINGPOINT 175)
(define-curl-option PROXYPASSWORD STRINGPOINT 176)
(define-curl-option NOPROXY STRINGPOINT 177)
(define-curl-option TFTP_BLKSIZE LONG 178)
(define-curl-option SOCKS5_GSSAPI_NEC LONG 180)
(define-curl-option PROTOCOLS LONG 181)
(define-curl-option REDIR_PROTOCOLS LONG 182)
(define-curl-option SSH_KNOWNHOSTS STRINGPOINT 183)
(define-curl-option SSH_KEYFUNCTION FUNCTIONPOINT 184)
(define-curl-option SSH_KEYDATA OBJECTPOINT 185)
(define-curl-option MAIL_FROM STRINGPOINT 186)
(define-curl-option MAIL_RCPT OBJECTPOINT 187)
(define-curl-option FTP_USE_PRET LONG 188)
(define-curl-option RTSP_REQUEST LONG 189)
(define-curl-option RTSP_SESSION_ID STRINGPOINT 190)
(define-curl-option RTSP_STREAM_URI STRINGPOINT 191)
(define-curl-option RTSP_TRANSPORT STRINGPOINT 192)
(define-curl-option RTSP_CLIENT_CSEQ LONG 193)
(define-curl-option RTSP_SERVER_CSEQ LONG 194)
(define-curl-option INTERLEAVEDATA OBJECTPOINT 195)
(define-curl-option INTERLEAVEFUNCTION FUNCTIONPOINT 196)
(define-curl-option WILDCARDMATCH LONG 197)
(define-curl-option CHUNK_BGN_FUNCTION FUNCTIONPOINT 198)
(define-curl-option CHUNK_END_FUNCTION FUNCTIONPOINT 199)
(define-curl-option FNMATCH_FUNCTION FUNCTIONPOINT 200)
(define-curl-option CHUNK_DATA OBJECTPOINT 201)
(define-curl-option FNMATCH_DATA OBJECTPOINT 202)
(define-curl-option RESOLVE OBJECTPOINT 203)
(define-curl-option TLSAUTH_USERNAME STRINGPOINT 204)
(define-curl-option TLSAUTH_PASSWORD STRINGPOINT 205)
(define-curl-option TLSAUTH_TYPE STRINGPOINT 206)
(define-curl-option TRANSFER_ENCODING LONG 207)
(define-curl-option CLOSESOCKETFUNCTION FUNCTIONPOINT 208)
(define-curl-option CLOSESOCKETDATA OBJECTPOINT 209)
(define-curl-option GSSAPI_DELEGATION LONG 210)
(define-curl-option DNS_SERVERS STRINGPOINT 211)
(define-curl-option ACCEPTTIMEOUT_MS LONG 212)
(define-curl-option TCP_KEEPALIVE LONG 213)
(define-curl-option TCP_KEEPIDLE LONG 214)
(define-curl-option TCP_KEEPINTVL LONG 215)
(define-curl-option SSL_OPTIONS LONG 216)
(define-curl-option MAIL_AUTH STRINGPOINT 217)
(define-curl-option SASL_IR LONG 218)
(define-curl-option XFERINFOFUNCTION FUNCTIONPOINT 219)
(define-curl-option XOAUTH2_BEARER STRINGPOINT 220)
(define-curl-option DNS_INTERFACE STRINGPOINT 221)
(define-curl-option DNS_LOCAL_IP4 STRINGPOINT 222)
(define-curl-option DNS_LOCAL_IP6 STRINGPOINT 223)
(define-curl-option LOGIN_OPTIONS STRINGPOINT 224)
(define-curl-option SSL_ENABLE_NPN LONG 225)
(define-curl-option SSL_ENABLE_ALPN LONG 226)
(define-curl-option EXPECT_100_TIMEOUT_MS LONG 227)
(define-curl-option PROXYHEADER OBJECTPOINT 228)
(define-curl-option HEADEROPT LONG 229)
(define-curl-option PINNEDPUBLICKEY STRINGPOINT 230)
(define-curl-option UNIX_SOCKET_PATH STRINGPOINT 231)
(define-curl-option SSL_VERIFYSTATUS LONG 232)
(define-curl-option SSL_FALSESTART LONG 233)
(define-curl-option PATH_AS_IS LONG 234)
(define-curl-option PROXY_SERVICE_NAME STRINGPOINT 235)
(define-curl-option SERVICE_NAME STRINGPOINT 236)
(define-curl-option PIPEWAIT LONG 237)
(define-curl-option DEFAULT_PROTOCOL STRINGPOINT 238)
(define-curl-option STREAM_WEIGHT LONG 239)
(define-curl-option STREAM_DEPENDS OBJECTPOINT 240)
(define-curl-option STREAM_DEPENDS_E OBJECTPOINT 241)
(define-curl-option TFTP_NO_OPTIONS LONG 242)
(define-curl-option CONNECT_TO OBJECTPOINT 243)
(define-curl-option TCP_FASTOPEN LONG 244)
(define-curl-option KEEP_SENDING_ON_ERROR LONG 245)
(define-curl-option PROXY_CAINFO STRINGPOINT 246)
(define-curl-option PROXY_CAPATH STRINGPOINT 247)
(define-curl-option PROXY_SSL_VERIFYPEER LONG 248)
(define-curl-option PROXY_SSL_VERIFYHOST LONG 249)
(define-curl-option PROXY_SSLVERSION LONG 250)
(define-curl-option PROXY_TLSAUTH_USERNAME STRINGPOINT 251)
(define-curl-option PROXY_TLSAUTH_PASSWORD STRINGPOINT 252)
(define-curl-option PROXY_TLSAUTH_TYPE STRINGPOINT 253)
(define-curl-option PROXY_SSLCERT STRINGPOINT 254)
(define-curl-option PROXY_SSLCERTTYPE STRINGPOINT 255)
(define-curl-option PROXY_SSLKEY STRINGPOINT 256)
(define-curl-option PROXY_SSLKEYTYPE STRINGPOINT 257)
(define-curl-option PROXY_KEYPASSWD STRINGPOINT 258)
(define-curl-option PROXY_SSL_CIPHER_LIST STRINGPOINT 259)
(define-curl-option PROXY_CRLFILE STRINGPOINT 260)
(define-curl-option PROXY_SSL_OPTIONS LONG 261)
(define-curl-option PRE_PROXY STRINGPOINT 262)
(define-curl-option PROXY_PINNEDPUBLICKEY STRINGPOINT 263)
(define-curl-option ABSTRACT_UNIX_SOCKET STRINGPOINT 264)
(define-curl-option SUPPRESS_CONNECT_HEADERS LONG 265)
(define-curl-option REQUEST_TARGET STRINGPOINT 266)
(define-curl-option SOCKS5_AUTH LONG 267)
(define-curl-option SSH_COMPRESSION LONG 268)
(define-curl-option MIMEPOST OBJECTPOINT 269)
(define-curl-option TIMEVALUE_LARGE OFF_T 270)
(define-curl-option HAPPY_EYEBALLS_TIMEOUT_MS LONG 271)
(define-curl-option RESOLVER_START_FUNCTION FUNCTIONPOINT 272)
(define-curl-option RESOLVER_START_DATA OBJECTPOINT 273)
(define-curl-option HAPROXYPROTOCOL LONG 274)
(define-curl-option DNS_SHUFFLE_ADDRESSES LONG 275)
(define-curl-option TLS13_CIPHERS STRINGPOINT 276)
(define-curl-option PROXY_TLS13_CIPHERS STRINGPOINT 277)
(define-curl-option DISALLOW_USERNAME_IN_URL LONG 278)
(define-curl-option DOH_URL STRINGPOINT 279)
(define-curl-option UPLOAD_BUFFERSIZE LONG 280)
(define-curl-option UPKEEP_INTERVAL_MS LONG 281)
(define-curl-option CURLU OBJECTPOINT 282)
(define-curl-option TRAILERFUNCTION FUNCTIONPOINT 283)
(define-curl-option TRAILERDATA OBJECTPOINT 284)
(define-curl-option HTTP09_ALLOWED LONG 285)
(define-curl-option ALTSVC_CTRL LONG 286)
(define-curl-option ALTSVC STRINGPOINT 287)
(define-curl-option MAXAGE_CONN LONG 288)

(define-struct info-data
   type
   value)

(define *curl-infos*
   (create-hashtable))

(define-syntax define-curl-info
   (syntax-rules ()
      ((_ name type val)
       (let ((info-name (snake-case->lisp-case (quote name))))
          (hashtable-put! *curl-infos* info-name
             (info-data (quote type) (+fx (get-info-base-val (quote type)) val)))))))

(define +curl-info-string+   #x100000)   
(define +curl-info-long+     #x200000)
(define +curl-info-double+   #x300000)
(define +curl-info-slist+    #x400000)
(define +curl-info-ptr+      #x400000)
(define +curl-info-socket+   #x500000)
(define +curl-info-off-t+     #x600000)
(define +curl-info-mask+     #x0fffff)
(define +curl-info-typemask+ #xf00000)

(define (get-info-base-val::long type::symbol)
   (case type
      ((STRING) +curl-info-string+)
      ((LONG) +curl-info-long+)
      ((DOUBLE) +curl-info-double+)
      ((SLIST) +curl-info-slist+)
      ((PTR) +curl-info-ptr+)
      ((SOCKET) +curl-info-socket+)
      ((OFF_T) +curl-info-off-t+)
      ((MASK) +curl-info-mask+)
      ((TYPEMASK) +curl-info-typemask+)
      (else
       (error "get-info-base-val" "unknown type" type))))



(define-syntax address-of
   (syntax-rules ()
      ((_ val)
       (pragma::void* "((void*)&$1)" val))))

(define (curl-get-string-info handle::curl* info::symbol)
   (let ((result::string (make-string-ptr-null))
         (data (hashtable-get *curl-infos* info)))
      (curl-easy-getinfo handle
         (let ((val::long (info-data-value data)))
            (pragma::curl-info "((CURLINFO) $1)" val))
         (address-of result))
      (if (string-ptr-null? result)
          ""
          ;; copy the string because result is owned by the curl internals
          ;; and will be freed when curl_easy_cleanup is called.
          (string-copy result))))

(define (curl-get-long-info handle::curl* info::symbol)
   (let ((result::long 0)
         (data (hashtable-get *curl-infos* info)))
      (curl-easy-getinfo handle
         (let ((val::long (info-data-value data)))
            (pragma::curl-info "((CURLINFO) $1)" val))
         (address-of result))
      result))

(define (curl-get-double-info handle::curl* info::symbol)
   (let ((result::double 0.0)
         (data (hashtable-get *curl-infos* info)))
      (curl-easy-getinfo handle
         (let ((val::long (info-data-value data)))
            (pragma::curl-info "((CURLINFO) $1)" val))
         (address-of result))
      result))

(define (curl-get-slist-info handle::curl* info::symbol)
   (let ((result::curl-slist*  (make-null-curl-slist*))
         (data (hashtable-get *curl-infos* info)))
      (curl-easy-getinfo handle
         (let ((val::long (info-data-value data)))
            (pragma::curl-info "((CURLINFO) $1)" val))
         (address-of result))
      (let ((res (slist->list result)))
         (curl-slist-free result)
         res)))

(define (get-info-accessor info::symbol)
   (let ((data (hashtable-get *curl-infos* info)))
      (if data
          (case (info-data-type data)
             ((STRING)
              curl-get-string-info)
             ((LONG OFF_T)
              curl-get-long-info)
             ((DOUBLE)
              curl-get-double-info)
             ((SLIST PTR)
              curl-get-slist-info)
             (else
              (error "get-info-accessor" "unsupported type" (info-data-type data)))
             ))))

(define (curl-get-info handle::curl* info::symbol)
   ((get-info-accessor info) handle info))

(define-curl-info EFFECTIVE_URL STRING 1)
(define-curl-info RESPONSE_CODE LONG 2)
(define-curl-info TOTAL_TIME DOUBLE 3)
(define-curl-info NAMELOOKUP_TIME DOUBLE 4)
(define-curl-info CONNECT_TIME DOUBLE 5)
(define-curl-info PRETRANSFER_TIME DOUBLE 6)
(define-curl-info SIZE_UPLOAD DOUBLE 7)
(define-curl-info SIZE_UPLOAD_T OFF_T 7)
(define-curl-info SIZE_DOWNLOAD DOUBLE 8)
(define-curl-info SIZE_DOWNLOAD_T OFF_T 8)
(define-curl-info SPEED_DOWNLOAD DOUBLE 9)
(define-curl-info SPEED_DOWNLOAD_T OFF_T 9)
(define-curl-info SPEED_UPLOAD DOUBLE 10)
(define-curl-info SPEED_UPLOAD_T OFF_T 10)
(define-curl-info HEADER_SIZE LONG 11)
(define-curl-info REQUEST_SIZE LONG 12)
(define-curl-info SSL_VERIFYRESULT LONG 13)
(define-curl-info FILETIME LONG 14)
(define-curl-info FILETIME_T OFF_T 14)
(define-curl-info CONTENT_LENGTH_DOWNLOAD DOUBLE 15)
(define-curl-info CONTENT_LENGTH_DOWNLOAD_T OFF_T 15)
(define-curl-info CONTENT_LENGTH_UPLOAD DOUBLE 16)
(define-curl-info CONTENT_LENGTH_UPLOAD_T OFF_T 16)
(define-curl-info STARTTRANSFER_TIME DOUBLE 17)
(define-curl-info CONTENT_TYPE STRING 18)
(define-curl-info REDIRECT_TIME DOUBLE 19)
(define-curl-info REDIRECT_COUNT LONG 20)
(define-curl-info PRIVATE STRING 21)
(define-curl-info HTTP_CONNECTCODE LONG 22)
(define-curl-info HTTPAUTH_AVAIL LONG 23)
(define-curl-info PROXYAUTH_AVAIL LONG 24)
(define-curl-info OS_ERRNO LONG 25)
(define-curl-info NUM_CONNECTS LONG 26)
(define-curl-info SSL_ENGINES SLIST 27)
(define-curl-info COOKIELIST SLIST 28)
(define-curl-info LASTSOCKET LONG 29)
(define-curl-info FTP_ENTRY_PATH STRING 30)
(define-curl-info REDIRECT_URL STRING 31)
(define-curl-info PRIMARY_IP STRING 32)
(define-curl-info APPCONNECT_TIME DOUBLE 33)
(define-curl-info CERTINFO PTR 34)
(define-curl-info CONDITION_UNMET LONG 35)
(define-curl-info RTSP_SESSION_ID STRING 36)
(define-curl-info RTSP_CLIENT_CSEQ LONG 37)
(define-curl-info RTSP_SERVER_CSEQ LONG 38)
(define-curl-info RTSP_CSEQ_RECV LONG 39)
(define-curl-info PRIMARY_PORT LONG 40)
(define-curl-info LOCAL_IP STRING 41)
(define-curl-info LOCAL_PORT LONG 42)
(define-curl-info TLS_SESSION PTR 43)
(define-curl-info ACTIVESOCKET SOCKET 44)
(define-curl-info TLS_SSL_PTR PTR 45)
(define-curl-info HTTP_VERSION LONG 46)
(define-curl-info PROXY_SSL_VERIFYRESULT LONG 47)
(define-curl-info PROTOCOL LONG 48)
(define-curl-info SCHEME STRING 49)
(define-curl-info TOTAL_TIME_T OFF_T 50)
(define-curl-info NAMELOOKUP_TIME_T OFF_T 51)
(define-curl-info CONNECT_TIME_T OFF_T 52)
(define-curl-info PRETRANSFER_TIME_T OFF_T 53)
(define-curl-info STARTTRANSFER_TIME_T OFF_T 54)
(define-curl-info REDIRECT_TIME_T OFF_T 55)
(define-curl-info APPCONNECT_TIME_T OFF_T 56)

(define (auth-type->long::long type::symbol)
   (case type
      ((none) 0)
      ((basic) (bit-lsh 1 0))
      ((digest) (bit-lsh 1 1))
      ((negotiate gssnegotiate gssapi) (bit-lsh 1 2))
      ((ntlm) (bit-lsh 1 3))
      ((digest-ie) (bit-lsh 1 4))
      ((ntlm-wb) (bit-lsh 1 5))
      ((bearer) (bit-lsh 1 6))
      ((only) (bit-lsh 1 31))
      ((any) (bit-not (auth-type->long 'digest-ie)))
      ((anysafe) (bit-not (bit-or (auth-type->long 'basic)
                             (auth-type->long 'digest-ie))))
      (else
       (error "auth-type->long" "unknown auth type" type))))


(define (curl-init)
   (let ((ret (curl-global-init curl-global-all)))
      (when (not (=curl-code? ret (curl-code-curle-ok)))
         (raise (instantiate::&curl-initialization-exception
                   (proc "curl-init")
                   (msg  "failed to initialize libcurl")
                   (obj ret))))
      (register-exit-function! (lambda (exit-value)
                                  ; we ignore the exit-value
                                  ; and always cleanup
                                  (curl-cleanup)))))



(define (curl-cleanup)
   (curl-global-cleanup))


(define (get-cleanup-handlers)
   (let  ((res (thread-parameter 'curl-cleanup-handlers)))
      (if (not res)
          (let ((new-table (create-hashtable)))
             (thread-parameter-set! 'curl-cleanup-handlers new-table))
          res)))

(define (curl-cleanup-handler-add! handle handler::procedure)
   (hashtable-add! (get-cleanup-handlers)
      handle (lambda (obj current-value) (cons obj current-value))
      handler '()))

(define (cleanup-handlers-execute! handle)
   (let ((handlers (hashtable-get (get-cleanup-handlers) handle)))
      (when handlers
         (for-each (lambda (h) (h)) handlers)
         (hashtable-remove! (get-cleanup-handlers) handle))))

(define (curl-option-set! handle::obj option-name::symbol val::obj)
   (if (curl*? handle)
       (let ((h::curl* handle)
             (opt-info (hashtable-get *curl-options* option-name)))
          (if (and opt-info
                   ((option-data-validate opt-info) handle val))
              (let ((ret (curl-easy-setopt h
                            (let ((v::long (option-data-value opt-info)))
                               (pragma::curl-opt "((CURLoption)$1)" v))
                            ((option-data-convert opt-info) handle val))))
                 (if (not (=curl-code? ret (curl-code-curle-ok)))
                     (error "curl-option-set!"
                        (format "failed to set ~a to ~a" option-name)
                        ret)
                     #unspecified))
              (error "curl-option-set!" (format "invalid value for ~s option"
                                            option-name)
                 val)))
       (error "curl-option-set!" "invalid curl handle" handle)))


(define (make-curl)
   (let ((handle (curl-easy-init)))
      (curl-option-set! handle 'writefunction $bigloo-write-callback)
      (curl-option-set! handle 'writedata #f)
      (curl-option-set! handle 'readfunction $bigloo-read-callback)
      (curl-option-set! handle 'readdata #f)
      (curl-option-set! handle 'xferinfofunction $bigloo-progress-callback)
      (curl-option-set! handle 'xferinfodata #f)
      (curl-option-set! handle 'headerfunction $bigloo-header-callback)
      (curl-option-set! handle 'headerdata #f)
      handle))

(define (make-curl-multi)
   (curl-multi-init))

(define (make-curl-mime handle)
   (if (curl*? handle)
       (curl-mime-init handle)
       (error "make-curl-mime" "invalid argument -- requires curl* but recieved"
          handle)))

(define (curl-mime-free! mime)
   (if (curl-mime*? mime)
       (curl-mime-free mime)
       (error "curl-mime-free!" "invalid argument -- requires curl-mime* but received"
          mime)))

(define (curl-mime-addpart! mime)
   (if (curl-mime*? mime)
       (curl-mime-addpart mime)
       (error "curl-mime-addpart!" "invalid argument -- requires curl-mime* but received"
          mime)))

(define (curl-mime-name! part name::bstring)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-name part name)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-name!" "failed to set mime part name" ret)
              #unspecified))
       (error "curl-mime-name!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-mime-filename! part filename::bstring)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-filename part filename)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-filename!" "failed to set mime part file name" ret)
              #unspecified))
       (error "curl-mime-filename!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-mime-filedata! part filename::bstring)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-filedata part filename)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-filedata!" "failed to set mime part from file" ret)
              #unspecified))
       (error "curl-mime-filedata!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-mime-data! part data::bstring)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-data part data (string-length data))))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-data!" "failed to set mime data" ret)
              #unspecified))
       (error "curl-mime-data!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-mime-data-port! part port)
   (if (and (curl-mimepart*? part)
            (input-port? port))
       (curl-mime-data-cb part -1 $bigloo-read-callback $bigloo-seek-callback
          (pragma::curl-free-callback "NULL") (bcurl->void* port))
       (error "curl-mime-data-port!" "invalid arguments -- requires curl-mimepart* and input-port but received"
          (list part port))))

(define (curl-mime-type! part type::bstring)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-type part type)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-type!" "failed to set mime type" ret)
              #unspecified))
       (error "curl-mime-type!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-mime-subparts! part subparts)
   (if (and (curl-mimepart*? part) (curl-mime*? subparts))
       (let ((ret (curl-mime-subparts part subparts)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-subparts!" "failed to set subparts" ret)
              #unspecified))
       (error "curl-mime-subparts!" "invalid arguments -- requires curl-mimepart* and curl-mime* but received"
          (list part subparts))))

(define (curl-mime-headers! part headers::pair-nil)
   (if (curl-mimepart*? part)
       (let ((ret (curl-mime-headers part (header-list->curl-slist headers) 1)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-mime-headers!" "failed to set headers" ret)
              #unspecified))
       (error "curl-mime-headers!" "invalid argument -- requires curl-mimepart* but received"
          part)))

(define (curl-multi-add-handle! multi handle)
   (if (and (curl-multi*? multi)
            (curl*? handle))
       (let ((res (curl-multi-add-handle multi handle)))
          (when (not (=curl-multi-code? res (curl-multi-code-curlm-ok)))
             (error "curl-multi-add-handle!" "failed to add handle" res))
          #unspecified)
       (error "curl-multi-add-handle!" "invalid arguments -- require curl-multi* and curl* but received"
                (list multi handle))))


(define (curl-multi-remove-handle! multi handle)
   (if (and (curl-multi*? multi)
            (curl*? handle))
       (let ((res (curl-multi-add-handle multi handle)))
          (when (not (=curl-multi-code? res (curl-multi-code-curlm-ok)))
             (error "curl-multi-remove-handle!" "failed to add handle" res))
          #unspecified)
       (error "curl-multi-remove-handle!" "invalid arguments -- require curl-multi* and curl* but received"
                (list multi handle))))

(define (curl-multi-info-read! multi)
   (if (curl-multi*? multi)
       (let* ((remaining-msgs::int 0)
             (msg (curl-multi-info-read multi (addr-of-int remaining-msgs))))
          (if (curl-msg*-null? msg)
              (values '() remaining-msgs)
              (values (cons (curl-msg*-handle msg) (curl-msg*-result msg)) remaining-msgs)))
       (error "curl-multi-info-read!" "argument must be a curl-multi pointer, received"
          multi)))

(define (curl-multi-wakeup! multi)
   (if (curl-multi*? multi)
       (let ((res (curl-multi-wakeup multi)))
          (when (not (=curl-multi-code? res (curl-multi-code-curlm-ok)))
             (error "curl-multi-wakeup!" "failed to execute" res)))
       (error "curl-multi-wakeup!" "argument must be a curl-multi pointer, recieved"
          multi)))



(define (curl-cleanup! handle::obj)
   (if (curl*? handle)
       (let ((h::curl* handle))
          (cleanup-handlers-execute! handle)
          (curl-easy-cleanup h))
       (error "curl-cleanup!" "handle must be curl pointer, received instead"
          handle)))

(define (curl-multi-cleanup! handle)
   (if (curl-multi*? handle)
       (let ((h::curl-multi* handle))
          (let ((ret (curl-multi-cleanup h)))
             (when (not (=curl-multi-code? ret (curl-multi-code-curlm-ok)))
                (raise (instantiate::&curl-cleanup-exception
                          (proc "curl-multi-cleanup!")
                          (msg "failed to cleanup curl multi")
                          (obj ret))))
             #unspecified))
       (error "curl-multi-cleanup!" "handle must be curl-multi pointer, received instead"
          handle)))

(define (bigloo-write-callback::long data::string
           size::long num-members::long user-data::void*)
   (let ((out (bcurl-void*->obj user-data))
         (size::long (*fx size num-members)))
      (pragma::obj "bgl_write($1, (unsigned char*)$2, $3)"
         (if (not out) (current-output-port) out) data size)
      size))

(define (bigloo-read-callback::ulong buffer::string size::ulong num-items::ulong
           user-data::void*)
   (let ((in (bcurl-void*->obj user-data))
         (size::long (*fx size num-items)))
      ($rgc-blit-string! (if (not in) (current-input-port) in) buffer 0 size)))

(define (bigloo-seek-callback::int instream::void* offset::long origin::int)
   (let* ((in (bcurl-void*->obj instream))
          (pos (cond ((= origin $seek-set)
                      offset)
                     ((= origin $seek-cur)
                      (+ (input-port-position in)
                         offset))
                     ((= origin $seek-end)
                      (+ (input-port-length in) offset))
                     (else
                      (error "bigloo-seek-callback" "unsupported seek origin" origin)))))
      (with-handler
         (lambda (e)
            (if (isa? e &io-port-error)
                (let ((e::&io-port-error e))
                   (if (or (equal? (-> e obj) $ESPIPE)
                           (equal? (-> e obj)
                              "input-port does not support seeking"))
                       $curl-seekfunc-cantseek
                       $curl-seekfunc-fail))
                (raise e)))
         (set-input-port-position! (if (not in) (current-input-port) in) pos)
         $curl-seekfunc-ok)))

(define (bigloo-progress-callback::int user-data::void* download-total::int64
           download-now::int64 upload-total::int64
           upload-now::int64)
   (let ((proc (bcurl-void*->obj user-data)))
      (if proc
          (proc download-total download-now upload-total upload-now)
          0)))

(define (bigloo-header-callback::long data::string
           size::long num-members::long user-data::void*)
   (let ((out (bcurl-void*->obj user-data))
         (size::long (*fx size num-members)))
      (when out
         (pragma::obj "bgl_write($1, (unsigned char*)$2, $3)"
            out data size))
      size))

(define (bigloo-opensocket-callback::int clientp::void* purpose::curl-socktype
           addr::curl-sockaddr*)
   (let* ((s::socket (bcurl-void*->obj clientp))
          (fd::int (bsocket->fd s)))
      (if (=curl-socktype? purpose (curl-socktype-ipx))
          fd
          $curl-socket-bad )))

(define (bigloo-sockopt-callback::int clientp::void* fd::int purpose::curl-socktype)
   (let ((sop::procedure (bcurl-void*->obj clientp)))
      (sop fd (curl-socktype->symbol purpose))))

(define (bigloo-closesocket-callback::int clientp::void* item::int)
   (let ((csp::procedure (bcurl-void*->obj clientp)))
      (csp item)))
            
(define (curl-perform! handle)
   (if (curl*? handle)
       (let* ((h::curl* handle)
              (ret (curl-easy-perform h)))
          (if (not (=curl-code? ret (curl-code-curle-ok)))
              (error "curl-perform!" "failed execution" ret)
              #unspecified))
       (error "curl-perform!" "invalid curl handle" handle)))

(define (curl-multi-perform! multi)
   (if (curl-multi*? multi)
       (let* ((running::int 0)
              (ret (curl-multi-perform multi (addr-of-int running))))
          (cond ((=curl-multi-code? ret (curl-multi-code-curlm-ok))
                 running)
                ((=curl-multi-code? ret (curl-multi-code-curlm-call-multi-perform))
                 (curl-multi-perform! multi))
                (else
                 (error "curl-mulit-perform!" "failed execution" ret)))))
   (error "curl-multi-perform!" "invalid curl-multi handle" multi))

(define *curl-init* #f)

(when (not *curl-init*)
   (curl-init)
   (set! *curl-init* #t))


(define (header-list->curl-slist headers::pair-nil)
   (let ((slist (make-null-curl-slist*)))
      (for-each (lambda (p)
                   (let* ((header (format "~a:~a" (car p) (cdr p)))
                          (tmp (curl-slist-append slist header)))
                      (if (curl-slist*-null? tmp)
                          (begin
                             (curl-slist-free-all slist)
                             (error "convert"
                                "failed to allocate a curl string list"
                                tmp))
                          (set! slist tmp))))
         headers)
      slist))

(define (slist->list slist::curl-slist*)
   (let loop ((res '())
              (cur::curl-slist* slist))
      (if (curl-slist*-null? cur)
          res
          (let ((next::curl-slist* (curl-slist*-next cur)))
             (loop (cons (string-copy (curl-slist*-data cur)) res)
                next)))))


(define (curl-slist-free lst::curl-slist*)
   (curl-slist-free-all lst))

